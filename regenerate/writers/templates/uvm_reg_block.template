/*----------------------------------------------------------------------------
 *
 * {{prj.name}} register package
 *
 * Generated: {{current_date}}
 *
 *----------------------------------------------------------------------------
 */

`include "uvm_macros.svh"

package {{prj.short_name}}_reg_pkg;

   import uvm_pkg::*;

   /*
    * Controls the handling of the volatile bit. By default, we try to adhere
    * to the strict definition of UVM - any register that has the potential of
    * changing between reads should be marked as volatile. This does impact
    * some usages of the uvm_reg.mirror(UVM_CHECK) function. So if 
    * s_relaxed_volitile is set to a 1, then only registers explicity marked
    * as volatile in regenerate will be identified as volatile. Fields that
    * have an input signal that can change the value will not. In this case,
    * it is the responsibility of the user to manage this potential volatility
    * on their own.
    */
   bit s_relaxed_volatile = 1'b0;

   int s_access_map[string][string] = '{
{% for map in prj.get_address_maps() %}
      "{{map.name}}" : '{
{%    for grp in prj.access_map[map.name] %}
{%      for block in prj.access_map[map.name][grp] %}
{%        if prj.access_map[map.name][grp][block] %}
         "{{grp}}.{{block}}" : {{prj.access_map[map.name][grp][block]}},
{%        endif %}
{%      endfor %}
{%    endfor %}
         default: 0
      }{% if not loop.last %},{% endif %}

{% endfor %}
   };

   /*-------------------------------------------------------------------------
    *
    * Register classes
    *
    *-------------------------------------------------------------------------
    */

{% for db in dblist %}

  {%- if db.coverage %}
  
   class {{db.set_name}}_reg_access_wrapper extends uvm_object;

      `uvm_object_utils({{db.set_name}}_reg_access_wrapper)

      static int s_num = 0;

      covergroup cov_addr(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

         option.per_instance = 1;
         option.name = name;

         READ_ADDR: coverpoint addr iff (is_read) {
            {% for reg in db.get_all_registers()|remove_no_uvm %}
              {% if reg.flags.do_not_cover == False and reg.is_completely_write_only() == False %}
                {% if reg.dimension > 1 %}
           bins r_{{fix_reg(reg)}} = { {% for i in range(0, reg.dimension) %}'h{{ '%x' % (reg.address + (i * (reg.width // 8)),) }}{% if not loop.last %}, {% endif %}{% endfor %} };
                {% else %}
           bins r_{{fix_reg(reg)}} = { 'h{{ '%x' % reg.address }} };
                {% endif %}
              {% endif %}
            {% endfor %}
         }

         WRITE_ADDR: coverpoint addr iff (!is_read) {
            {% for reg in db.get_all_registers()|remove_no_uvm %}
              {% if reg.is_completely_read_only() == False %}
                {% if reg.flags.do_not_cover == False and reg.is_completely_read_only() == False %}
                  {% if reg.dimension > 1 %}
           bins w_{{fix_reg(reg)}} = { {% for i in range(0, reg.dimension) %}'h{{ '%x' % (reg.address + (i * (reg.width // 8)),) }}{% if not loop.last %}, {% endif %}{% endfor %} };
                  {% else %}
           bins w_{{fix_reg(reg)}} = { 'h{{ '%x' % reg.address }} };
                  {% endif %}
                {% endif %}
              {% endif %}
            {% endfor %}
         }

      endgroup : cov_addr

      function new(string name = "{{db.set_name}}_reg_access_wrapper");
         cov_addr = new($sformatf("%s_%0d", name, s_num++));
      endfunction : new

      function void sample(uvm_reg_addr_t offset, bit is_read);
         cov_addr.sample(offset, is_read);
      endfunction: sample

   endclass : {{db.set_name}}_reg_access_wrapper
  {% endif %}

  {% for reg in db.get_all_registers()|remove_no_uvm %}
    {% if reg.ram_size %}
      {% set num_bytes = reg.width // 8 %}
   class mem_{{db.set_name}}_{{fix_reg(reg)}} extends uvm_mem;

      `uvm_object_utils(mem_{{db.set_name}}_{{fix_reg(reg)}})

      function new (string name = "mem_{{db.set_name}}_{{fix_reg(reg)}}");
         super.new(name, {{reg.ram_size // num_bytes}}, {{reg.width}}, "RW", build_coverage(UVM_NO_COVERAGE));
      endfunction : new

   endclass : mem_{{db.set_name}}_{{fix_reg(reg)}}

    {% else %}

   class reg_{{db.set_name}}_{{fix_reg(reg)}} extends uvm_reg;

      `uvm_object_utils(reg_{{db.set_name}}_{{fix_reg(reg)}})

     {% for field in reg.get_bit_fields() %}
      rand uvm_reg_field {{fix_name(field)}};
     {% endfor %}

     {% if db.coverage %}
      local uvm_reg_data_t m_data;
      local uvm_reg_data_t m_be;
      local bit m_is_read;

     {% endif %}
     {% for field  in reg.get_bit_fields() %}
     {%   if field.flags.can_randomize and field.values|length > 0 %}
      constraint con_{{fix_name(field)}} {
         {{fix_name(field)}}.value inside { {% for value in field.values %}{{field.width}}'h{{value.value}}{% if not loop.last %}, {% endif %}{% endfor %} };
      }
     {%   endif %}

     {%- endfor -%}
     {% if db.coverage %}
       {% if reg.get_bit_fields_with_values() | length > 0 %}
         {% if reg.flags.do_not_cover == False %}

      covergroup cov_fields;
         option.per_instance = 1;

           {% for field in reg.get_bit_fields_with_values() %}
         {{fix_name(field)|upper}}: coverpoint {{field.name|lower}}.value[{{field.msb}}:{{field.lsb}}] {
               {% for value in field.values %}
            bins {{fix_name(field)}}_{{value.value}} = {'h{{value.value}} };
               {% endfor %}
         }
           {% endfor %}
         {% endif %}
      endgroup : cov_fields
       {% endif %}

      covergroup cov_bits;
         option.per_instance = 1;

         {% for field in reg.get_bit_fields() %}
           {% if reg.flags.do_not_cover == False and field.values|length == 0 %}
             {% for i in range(field.lsb, field.msb+1) %}
               {% if field.is_read_only() == 0 %}
         {{fix_name(field)|upper}}_W{{i}}: coverpoint (m_data[{{i}}]) iff (!m_is_read && m_be[{{(i/8)|int}}]);
               {% endif %}
               {% if field.is_read_only() and field.is_constant() %}
         {{fix_name(field)|upper}}_R{{i}}: coverpoint (m_data[{{i}}]) iff (m_is_read) {bins ro_{{i}} = { {{field.reset_value_bit(i - field.lsb)}} }; }
               {% elif field.is_write_only() == False %}
         {{fix_name(field)|upper}}_R{{i}}: coverpoint (m_data[{{i}}]) iff (m_is_read);
               {% endif %}
             {% endfor %}
           {% endif %}
         {% endfor %}
      endgroup : cov_bits
     {% endif %}

      function new(string name = "{{fix_reg(reg)}}");
         super.new(name, {{reg.width}}, build_coverage(UVM_CVR_FIELD_VALS|UVM_CVR_REG_BITS));

         add_coverage(build_coverage(UVM_CVR_FIELD_VALS|UVM_CVR_REG_BITS));
	 
     {% if db.coverage and reg.flags.do_not_cover == False %}
       {% if reg.get_bit_fields() | length > 0 %}
         if (has_coverage(UVM_CVR_REG_BITS)) begin
            cov_bits = new;
         end
       {% endif %}
       {% if reg.get_bit_fields_with_values() | length > 0 %}
         if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            cov_fields = new;
         end
       {% endif %}
     {% endif %}
      endfunction : new

     {% if db.coverage and reg.flags.do_not_cover == False %}
      function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en,
                           bit is_read, uvm_reg_map map);
         super.sample(data, byte_en, is_read, map);
       {% if reg.get_bit_fields() | length > 0 %}
         if (has_coverage(UVM_CVR_REG_BITS)) begin
            m_data = data;
            m_be = byte_en;
            m_is_read = is_read;
            cov_bits.sample();
         end
       {% endif %}
       {% if reg.get_bit_fields_with_values() | sort(attribute='lsb') | length > 0 %}
         if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            sample_values();
            cov_fields.sample();
         end
       {% endif %}

      endfunction: sample
     {% endif %}

      virtual function void build();
     {% for field in reg.get_bit_fields() %}
         {{fix_name(field)}} = uvm_reg_field::type_id::create("{{fix_name(field)}}");
     {% endfor %}
     {%- for field in reg.get_bit_fields() -%}
        {%- if field.flags.volatile %}
          {% set volatile = "1" %}
        {% elif TYPE_TO_INPUT[field.type] %}
          {% set volatile = "!" + prj.short_name + "_reg_pkg::s_relaxed_volatile" %}
        {% else %}
          {% set volatile = "0" %}
        {% endif %}
        {%- set reset = "%d'h%x" % (field.width, field.reset_value) %}
        {%- set has_reset = 1 %}
        {%- set ind_access = individual_access(field, reg) %}
        {%- set access = ACCESS_MAP[field.field_type] %}

         {{fix_name(field)}}.configure(this, {{field.width}}, {{field.lsb}}, "{{access}}", {{volatile}}, {{reset}}, {{has_reset}}, {% if field.flags.can_randomize %}1{% else %}0{% endif %}, {{ind_access}});
     {%- endfor %}

      {% if reg.no_reset_test() == True or reg.share != 0 %}
         uvm_resource_db #(bit)::set({"REG::", get_full_name()}, "NO_REG_TESTS", 1, this);
      {% elif reg.strict_volatile() %}
         {% if reg.loose_volatile() %}
         uvm_resource_db #(bit)::set({"REG::", get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);
         {% else %}
         if ({{prj.short_name}}_reg_pkg::s_relaxed_volatile == 1'b0) begin
            uvm_resource_db #(bit)::set({"REG::", get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);
         end
         {% endif %}
      {% endif %}
      endfunction : build

   endclass : reg_{{db.set_name}}_{{fix_reg(reg)}}
    {% endif %}
   {% endfor %}
{% endfor %}

  /*--------------------------------------------------------------------------
   *
   * Regset instantiations
   *
   *--------------------------------------------------------------------------
   */
{% for db, grp, grp_map in db_grp_maps %}
  class {{grp.inst_name}}_{{db.set_name}}_regset extends uvm_reg_block;

    `uvm_object_utils({{grp.inst_name}}_{{db.set_name}}_regset)

   {% for reg in db.get_all_registers()|remove_no_uvm %}
     {% if reg.ram_size %}
    mem_{{db.set_name}}_{{fix_reg(reg)}} {{fix_reg(reg)}};
     {% else %}
       {% if reg.dimension > 1 %}
    rand reg_{{db.set_name}}_{{fix_reg(reg)}} {{fix_reg(reg)}}[{{reg.dimension}}];
       {% else %}
    rand reg_{{db.set_name}}_{{fix_reg(reg)}} {{fix_reg(reg)}};
       {% endif %}
     {% endif %}
   {% endfor %}
   {% for map in grp_map %}
    uvm_reg_map {{map}}_map;
   {% endfor %}
   {% for map in grp_map %}
    bit disable_{{map}}_map = 1'b0;
   {% endfor %}

   {% if db.coverage %}
    {{db.set_name}}_reg_access_wrapper {{db.set_name}}_access_cg;
   {% endif %}

    function new(string name = "{{grp.inst_name}}_{{db.set_name}}_regset");
       super.new(name, build_coverage(UVM_CVR_ADDR_MAP));
       add_coverage(build_coverage(UVM_CVR_ADDR_MAP));
    endfunction

    function string access_mode(string def, int force_mode);
       if (force_mode == 0) begin
          return def;
       end else if (force_mode == 1) begin
          return "RO";
       end else begin
          return "WO";
       end
    endfunction : access_mode	       

    virtual protected function uvm_reg_map build_address_map(string map_name, int unsigned width,
                                                             int force_mode);
       uvm_reg_map rmap;

       if ({{db.ports.data_bus_width}} > width) begin
          rmap = create_map(map_name, 'h0, width/8, UVM_LITTLE_ENDIAN);
       end else begin
          rmap = create_map(map_name, 'h0, {{(db.ports.data_bus_width/8)|int}}, UVM_LITTLE_ENDIAN);
       end

       if (force_mode != 3) begin
    {% for reg in db.get_all_registers()|remove_no_uvm %}
       {% if reg.share == 1 or reg.is_completely_read_only() %}
       {%   set mode = "RO" %}
       {% elif reg.share == 2 or reg.is_completely_write_only() %}
       {%   set mode = "WO" %}
       {% else %}
       {%   set mode = "RW" %}
       {% endif %}
       
       {% if reg.ram_size %}
          rmap.add_mem({{fix_reg(reg)}}, 'h{{"%04x" % reg.address}}, access_mode("{{mode}}", force_mode));
      {% else %}
         {% if reg.dimension > 1 %}
           {% for i in range(0, reg.dimension) %}
          rmap.add_reg({{fix_reg(reg)}}[{{i}}], 'h{{"%04x" % (reg.address + (i * (reg.width // 8)),)}}, access_mode("{{mode}}", force_mode));
           {% endfor %}
         {% else %}
          rmap.add_reg({{fix_reg(reg)}}, 'h{{"%04x" % reg.address}}, access_mode("{{mode}}", force_mode));
         {% endif %}
      {% endif %}
    {%- endfor %}
       end
       return rmap;
    endfunction : build_address_map

    function string extract_path(string msg);
       int start, stop;

       for (int i = 0; i < msg.len(); i++) begin
          if (msg[i] == ".") begin
             start = i + 1;
             break;
          end
       end

       stop = msg.len() - 1;
       for (int i = start; i < msg.len(); i++) begin
          if (msg[i] == "[") begin
             stop = i;
             break;
          end
       end
       return msg.substr(start, stop); 
    endfunction : extract_path

    virtual function void build();

{% if db.coverage %}
      if (has_coverage(UVM_CVR_ADDR_MAP)) begin
        {{db.set_name}}_access_cg = {{db.set_name}}_reg_access_wrapper::type_id::create("{{db.set_name}}_access_cg");
      end
{% endif %}

{% for reg in db.get_all_registers()|remove_no_uvm %}
{%   if reg.share == 0 %}
{%     set mode = "_" %}
{%   elif reg.share == 1 %}
{%     set mode = "_r_" %}
{%   else %}
{%     set mode = "_w_" %}
{%   endif %}
{%   if reg.ram_size %}
      {{fix_reg(reg)}} = mem_{{db.set_name}}_{{fix_reg(reg)}}::type_id::create("{{fix_reg(reg)}}");
      {{fix_reg(reg)}}.configure(this);
{%   else %}
{%     if reg.dimension > 1 %}
      foreach ({{fix_reg(reg)}}[i]) begin
         {{fix_reg(reg)}}[i] = reg_{{db.set_name}}_{{fix_reg(reg)}}::type_id::create("{{fix_reg(reg)}}");
         {{fix_reg(reg)}}[i].configure(this);
         {{fix_reg(reg)}}[i].build();
{%       for field in reg.get_bit_fields() %}
         {{fix_reg(reg)}}[i].add_hdl_path_slice($sformatf("r%02x{{mode}}{fix_name(field)}}", {{reg.address}} + (i * {{reg.width // 8}})), {{field.lsb}}, {{field.width}});
{%       endfor %}
      end
{%     else %}
      {{fix_reg(reg)}} = reg_{{db.set_name}}_{{fix_reg(reg)}}::type_id::create("{{fix_reg(reg)}}");
      {{fix_reg(reg)}}.configure(this);
      {{fix_reg(reg)}}.build();
{%       for field in reg.get_bit_fields() %}
      {{fix_reg(reg)}}.add_hdl_path_slice("r{{'%02x' % reg.address}}{{mode}}{{fix_name(field)}}", {{field.lsb}}, {{field.width}});
{%       endfor %}
{%     endif %}
{%   endif %}
{% endfor %}

   {% if grp_map|length == 1 %}
     {% for map in grp_map %}
      {{map}}_map = build_address_map("{{map}}_map", {{8 * prj.get_address_width(map)}}, s_access_map["{{map}}"][extract_path(get_full_name())]);
     {% endfor %}
   {% else %}
     {% for map in grp_map %}
      if (!disable_{{map}}_map) {{map}}_map = build_address_map("{{map}}_map", {{8 * prj.get_address_width(map)}}, s_access_map["{{map}}"][extract_path(get_full_name())]);
     {% endfor %}
   {% endif %}

    endfunction : build

   {% if db.coverage %}
    function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map  map);
       if (has_coverage(UVM_CVR_ADDR_MAP)) begin
          {{db.set_name}}_access_cg.sample(offset, is_read);
       end
    endfunction: sample
   {% endif %}

  endclass : {{grp.inst_name}}_{{db.set_name}}_regset

{% endfor %}

  /*--------------------------------------------------------------------------
   *
   * Blocks
   *
   *--------------------------------------------------------------------------
   */
{% for grp in group_maps %}

  class {{grp.inst_name}}_blk extends uvm_reg_block;

     `uvm_object_utils({{grp.inst_name}}_blk)

  {% for regset_inst in prj.blocks[grp.block].regset_insts %}
  {%    if regset_inst.repeat > 1 or regset_inst.array %}
     {{grp.inst_name}}_{{regset_inst.set_name}}_regset {{regset_inst.inst}}[{{regset_inst.repeat}}];
  {%    else %}
     {{grp.inst_name}}_{{regset_inst.set_name}}_regset {{regset_inst.inst}};
  {%    endif %}
  {% endfor %}

  {% for item in group_maps[grp] %}
     uvm_reg_map {{item}}_map;
  {% endfor %}
  {% for map in group_maps[grp] %}
     bit disable_{{map}}_map = 1'b0;
  {% endfor %}

     function new(string name = "{{grp.inst_name}}_blk");
        super.new(name, build_coverage(UVM_NO_COVERAGE));
     endfunction : new

     function void build();
  {% if group_maps[grp]|length > 1 %}
    {% for item in group_maps[grp] %}
        if (!disable_{{item}}_map) begin
           {{item}}_map = create_map("{{item}}_map", 0, {{prj.get_address_width(item)}}, UVM_LITTLE_ENDIAN);
        end
    {% endfor %}
  {% else %}
    {% for item in group_maps[grp] %}
        {{item}}_map = create_map("{{item}}_map", 0, {{prj.get_address_width(item)}}, UVM_LITTLE_ENDIAN);
    {% endfor %}
  {% endif %}

  {% for regset_inst in prj.blocks[grp.block].regset_insts %}
   {% set regset = prj.regsets[regset_inst.set_name] %}
   {% if regset_inst.repeat > 1 or regset.array %}
        for (int i = 0; i < {{regset_inst.repeat}}; i++) begin
           {{regset_inst.inst}}[i] = {{grp.inst_name}}_{{regset_inst.inst}}_regset::type_id::create($sformatf("{{regset_inst.inst}}[%0d]", i));
      {% if regset_inst.hdl: %}
           {{regset_inst.inst}}[i].configure(this, $sformatf("{{regset_inst.hdl}}", i));
      {% else %}
           {{regset_inst.inst}}[i].configure(this, "");
      {% endif %}
      
      {% for item in group_maps[grp] %}
           {{regset_inst.inst}}[i].disable_{{item}}_map = disable_{{item}}_map;
      {% endfor %}
      
           {{regset_inst.inst}}[i].build();
      {% for item in group_maps[grp] %}
        {% if group_maps[grp]| length > 1 %}
           if (!disable_{{item}}_map) begin
              {{item}}_map.add_submap({{regset_inst.inst}}[i].{{item}}_map, 'h{{"%x" % regset_inst.offset}} + (i * 'h{{"%x" % (2 ** regset.ports.address_bus_width,)}}));
           end
        {% else %}
           {{item}}_map.add_submap({{regset_inst.inst}}[i].{{item}}_map, 'h{{"%x" % regset_inst.offset}} + (i * 'h{{"%x" % (2 ** regset.ports.address_bus_width,)}}));
        {% endif %}
        {% if regset.no_uvm %}
           uvm_resource_db#(bit)::set({"REG::",{{regset_inst.inst}}[i].get_full_name(),".*"}, "NO_REG_TESTS", 1, this);
        {% endif %}
      {% endfor %}
        end
    {% else %}
        {{regset_inst.inst}} = {{grp.inst_name}}_{{regset_inst.set_name}}_regset::type_id::create("{{regset_inst.inst}}");
        {{regset_inst.inst}}.configure(this, "{{regset_inst.hdl}}");
	
      {% for item in group_maps[grp] %}
        {{regset_inst.inst}}.disable_{{item}}_map = disable_{{item}}_map;
      {% endfor %}
      
        {{regset_inst.inst}}.build();
      {% for item in group_maps[grp] %}
        {% if group_maps[grp]| length > 1 %}
        if (!disable_{{item}}_map) {{item}}_map.add_submap({{regset_inst.inst}}.{{item}}_map, 'h{{"%x" % regset_inst.offset}});
        {% else %}
        {{item}}_map.add_submap({{regset_inst.inst}}.{{item}}_map, 'h{{"%x" % regset_inst.offset}});
        {% endif %}
        {% if regset.no_uvm %}
        uvm_resource_db#(bit)::set({"REG::",{{regset_inst.inst}}.get_full_name(),".*"}, "NO_REG_TESTS", 1, this);
        {% endif %}
      {% endfor %}
    {%  endif %}
  {% endfor %}
      endfunction: build
  endclass : {{grp.inst_name}}_blk
{% endfor %}

  /* Top level register block */
  class {{prj.short_name}}_reg_block extends uvm_reg_block;

     `uvm_object_utils({{prj.short_name}}_reg_block)
{% for grp in group_maps %}
{%   if grp.repeat > 1 %}
     {{grp.inst_name}}_blk {{grp.inst_name}}[{{grp.repeat}}];
{%   else %}
     {{grp.inst_name}}_blk {{grp.inst_name}};
{%   endif %}
{%- endfor %}
{% for data in used_maps %}
     uvm_reg_map {{data}}_map;
{% endfor %}
{% if used_maps|length > 1 %}
  {% for data in used_maps %}
     bit disable_{{data}}_map = 1'b0;
  {% endfor %}
{% endif %}

     function new(string name = "{{prj.short_name}}_reg_block");
        super.new(name, build_coverage(UVM_NO_COVERAGE));
     endfunction : new

     function void build();

{% for map in prj.get_address_maps() %}
  {% if map.name in used_maps %}
    {% if used_maps|length > 1 %}
        if (!disable_{{map.name}}_map) {{map.name}}_map = create_map("{{map.name}}_map", 'h{{"%x" % map.base}}, {{prj.get_address_width(map.name)}}, UVM_LITTLE_ENDIAN);
    {% else %}
        {{map.name}}_map = create_map("{{map.name}}_map", 'h{{"%x" % map.base}}, {{prj.get_address_width(map.name)}}, UVM_LITTLE_ENDIAN);
    {% endif %}
  {% endif %}
{% endfor %}

{% for grp in group_maps %}
  {% if grp.repeat <= 1 %}
        {{grp.inst_name}} = {{grp.inst_name}}_blk::type_id::create("{{grp.inst_name}}");
    {% if grp.hdl != "" %}
        {{grp.inst_name}}.configure(this, "{{grp.hdl}}");
    {% else %}
        {{grp.inst_name}}.configure(this);
    {% endif %}
    {% if used_maps|length > 1 %}
      {% for set in group_maps[grp] %}
        {{grp.inst_name}}.disable_{{set}}_map = disable_{{set}}_map;
      {% endfor %}
    {% endif %}
        {{grp.inst_name}}.build();

    {% if used_maps|length > 1 %}
      {%- for mset in group_maps[grp] -%}
        if (!disable_{{mset}}_map) {{mset}}_map.add_submap({{grp.inst_name}}.{{mset}}_map, 'h{{"%x" % grp.address_base}});
      {% endfor %}
    {%- else -%}
      {% for mset in used_maps %}
        {{mset}}_map.add_submap({{grp.inst_name}}.{{mset}}_map, 'h{{"%x" % grp.address_base}});
      {% endfor %}

    {% endif %}
  {% else %}

        foreach ({{grp.inst_name}}[i]) begin
           {{grp.inst_name}}[i] = {{grp.inst_name}}_blk::type_id::create($sformatf("{{grp.inst_name}}[%0d]", i));
    {% if grp.hdl != "" %}
           {{grp.inst_name}}[i].configure(this, $sformatf("{{grp.hdl}}", i));
    {% else %}
           {{grp.inst_name}}[i].configure(this);
    {% endif %}
    {% for set in group_maps[grp] %}
           {{grp.inst_name}}[i].disable_{{set}}_map = disable_{{set}}_map;
    {% endfor %}
           {{grp.inst_name}}[i].build();

    {% for mset in group_maps[grp] %}
      {% set addr_size = prj.blocks[grp.block].address_size %}
    //DNA {{addr_size}}
           if (!disable_{{mset}}_map) {{mset}}_map.add_submap({{grp.inst_name}}[i].{{mset}}_map, 'h{{"%x" % grp.address_base}} + (i * 'h{{"%x" % addr_size}}));
    {% endfor %}
        end

  {% endif %}
{% endfor %}
        reset();
        lock_model();
     endfunction: build

  endclass : {{prj.short_name}}_reg_block

endpackage : {{prj.short_name}}_reg_pkg

