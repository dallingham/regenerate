{# -*- mode: Jinja2;-*- #}
/*----------------------------------------------------------------------------
 *
 * {{prj.name}} register package
 *
 * Generated: {{current_date}}
 *
 *----------------------------------------------------------------------------
 */

`include "uvm_macros.svh"

package {{prj.short_name}}_reg_pkg;

   import uvm_pkg::*;

   /*
    * Controls the handling of the volatile bit. By default, we try to adhere
    * to the strict definition of UVM - any register that has the potential of
    * changing between reads should be marked as volatile. This does impact
    * some usages of the uvm_reg.mirror(UVM_CHECK) function. So if 
    * s_relaxed_volitile is set to a 1, then only registers explicity marked
    * as volatile in regenerate will be identified as volatile. Fields that
    * have an input signal that can change the value will not. In this case,
    * it is the responsibility of the user to manage this potential volatility
    * on their own.
    */
   bit s_relaxed_volatile = 1'b0;
   int s_access_map[string][string] = '{
{% for map in prj.get_address_maps() %}
      "{{map.name}}" : '{
  {% for blkinst_uuid in prj.access_map[map.name] %}
    {% for reginst_uuid in prj.access_map[map.name][blkinst_uuid] %}
      {% if prj.access_map[map.name][blkinst_uuid][reginst_uuid] %}
	{% set blkinst = prj.get_blkinst_from_id(blkinst_uuid) %}
	{% set block = prj.get_block_from_block_inst(blkinst) %}
	{% set reginst = block.get_reginst_from_id(reginst_uuid) %}
        "{{blkinst.name}}.{{reginst.name}}" : {{prj.access_map[map.name][blkinst_uuid][reginst_uuid]}},
      {% endif %}
    {% endfor %}
  {% endfor %}
         default: 0
      }{% if not loop.last %},{% endif %}

{% endfor %}
   };

   /*-------------------------------------------------------------------------
    *
    * Register classes
    *
    *-------------------------------------------------------------------------
    */
{% for db, regset_inst, blk_inst, grp_map, tag in db_grp_maps %}
  {{- resolver.set_reginst(regset_inst.uuid) or '' -}}
  {{- resolver.set_blkinst(blk_inst.uuid) or '' -}}
  {%- if db.coverage %}
   class {{blk_inst.name}}__{{regset_inst.name}}__reg_access_wrapper extends uvm_object;

      `uvm_object_utils({{blk_inst.name}}__{{regset_inst.name}}__reg_access_wrapper)

      static int s_num = 0;

      covergroup cov_addr(string name) with function sample(uvm_reg_addr_t addr, bit is_read);

         option.per_instance = 1;
         option.name = name;

         READ_ADDR: coverpoint addr iff (is_read) {
            {% for reg in db.get_all_registers() | remove_no_uvm %}
              {% if reg.flags.do_not_cover == False and reg.is_completely_write_only() == False %}
                {% if reg.dimension.resolve() > 1 %}
           bins r_{{fix_reg(reg)}} = { {% for i in range(0, reg.dimension.resolve()) %}'h{{ '%x' % (reg.address + (i * (reg.width // 8)),) }}{% if not loop.last %}, {% endif %}{% endfor %} };
                {% else %}
           bins r_{{fix_reg(reg)}} = { 'h{{ '%x' % reg.address }} };
                {% endif %}
              {% endif %}
            {% endfor %}
         }

         WRITE_ADDR: coverpoint addr iff (!is_read) {
            {% for reg in db.get_all_registers() | remove_no_uvm %}
              {% if reg.is_completely_read_only() == False %}
                {% if reg.flags.do_not_cover == False and reg.is_completely_read_only() == False %}
                  {% if reg.dimension.resolve() > 1 %}
           bins w_{{fix_reg(reg)}} = { {% for i in range(0, reg.dimension.resolve()) %}'h{{ '%x' % (reg.address + (i * (reg.width // 8)),) }}{% if not loop.last %}, {% endif %}{% endfor %} };
                  {% else %}
           bins w_{{fix_reg(reg)}} = { 'h{{ '%x' % reg.address }} };
                  {% endif %}
                {% endif %}
              {% endif %}
            {% endfor %}
         }

      endgroup : cov_addr

      function new(
         string name = "{{blk_inst.name}}__{{regset_inst.name}}__reg_access_wrapper"
      );
         cov_addr = new($sformatf("%s_%0d", name, s_num++));
      endfunction : new

      function void sample(
         uvm_reg_addr_t offset,
         bit            is_read
      );
         cov_addr.sample(offset, is_read);
      endfunction: sample

   endclass : {{blk_inst.name}}__{{regset_inst.name}}__reg_access_wrapper
  {% endif %}

  {% for reg in db.get_all_registers() | remove_no_uvm %}
    {% if reg.ram_size %}
      {% set num_bytes = reg.width // 8 %}
   class mem_{{blk_inst.name}}__{{regset_inst.name}}_{{fix_reg(reg)}} extends uvm_mem;

      `uvm_object_utils(mem_{{blk_inst.name}}__{{regset_inst.name}}_{{fix_reg(reg)}})

      function new (
         string name = "mem_{{blk_inst.name}}__{{regset_inst.name}}_{{fix_reg(reg)}}"
      );
         super.new(
	    .name(name),
	    .size({{reg.ram_size // num_bytes}}),
	    .n_bits({{reg.width}}),
	    .access("RW"),
	    .has_coverage(build_coverage(UVM_NO_COVERAGE))
	 );
      endfunction : new

   endclass : mem_{{blk_inst.name}}__{{regset_inst.name}}_{{fix_reg(reg)}}

    {% else %}

   class reg__{{blk_inst.name}}__{{regset_inst.name}}__{{fix_reg(reg)}} extends uvm_reg;

      `uvm_object_utils(reg__{{blk_inst.name}}__{{regset_inst.name}}__{{fix_reg(reg)}})

     {% for field in reg.get_bit_fields() %}
      rand uvm_reg_field {{fix_name(field)}};
     {% endfor %}

     {% if db.coverage %}
      local uvm_reg_data_t m_data;
      local uvm_reg_data_t m_be;
      local bit m_is_read;

     {% endif %}
     {% for field  in reg.get_bit_fields() %}
     {%   if field.flags.can_randomize and field.values|length > 0 %}
      constraint con_{{fix_name(field)}} {
         {{fix_name(field)}}.value inside { {% for value in field.values %}{{field.width}}'h{{value.value}}{% if not loop.last %}, {% endif %}{% endfor %} };
      }
     {%   endif %}

     {%- endfor -%}
     {% if db.coverage %}
       {% if reg.get_bit_fields_with_values() | length > 0 %}
         {% if reg.flags.do_not_cover == False %}

      covergroup cov_fields;
         option.per_instance = 1;

           {% for field in reg.get_bit_fields_with_values() %}
         {{fix_name(field)|upper}}: coverpoint {{field.name|lower}}.value[{{field.msb.resolve()}}:{{field.lsb}}] {
               {% for value in field.values %}
            bins {{fix_name(field)}}_{{value.value}} = {'h{{value.value}} };
               {% endfor %}
         }
           {% endfor %}
         {% endif %}
      endgroup : cov_fields
       {% endif %}

      covergroup cov_bits;
         option.per_instance = 1;

         {% for field in reg.get_bit_fields() %}
           {% if reg.flags.do_not_cover == False and field.values|length == 0 %}
             {% for i in range(field.lsb, field.msb.resolve()+1) %}
               {% if field.is_read_only() == 0 %}
         {{fix_name(field)|upper}}_W{{i}}: coverpoint (m_data[{{i}}]) iff (!m_is_read && m_be[{{i // 8}}]);
               {% endif %}
               {% if field.is_read_only() and field.is_constant() %}
         {{fix_name(field)|upper}}_R{{i}}: coverpoint (m_data[{{i}}]) iff (m_is_read) {bins ro_{{i}} = { {{field.reset_value_bit(i - field.lsb)}} }; }
               {% elif field.is_write_only() == False %}
         {{fix_name(field)|upper}}_R{{i}}: coverpoint (m_data[{{i}}]) iff (m_is_read);
               {% endif %}
             {% endfor %}
           {% endif %}
         {% endfor %}
      endgroup : cov_bits
     {% endif %}

      function new(
         string name = "{{fix_reg(reg)}}"
      );
         super.new(
	    .name(name),
	    .n_bits({{reg.width}}),
	    .has_coverage(build_coverage(UVM_CVR_FIELD_VALS|UVM_CVR_REG_BITS))
	 );

         add_coverage(build_coverage(UVM_CVR_FIELD_VALS|UVM_CVR_REG_BITS));
	 
     {% if db.coverage and reg.flags.do_not_cover == False %}
       {% if reg.get_bit_fields() | length > 0 %}
         if (get_coverage(UVM_CVR_REG_BITS)) begin
            cov_bits = new;
         end
       {% endif %}
       {% if reg.get_bit_fields_with_values() | length > 0 %}
         if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            cov_fields = new;
         end
       {% endif %}
     {% endif %}
      endfunction : new

     {% if db.coverage and reg.flags.do_not_cover == False %}
      function void sample(
         uvm_reg_data_t data, uvm_reg_data_t byte_en,
         bit is_read,
         uvm_reg_map map
      );
         super.sample(data, byte_en, is_read, map);
       {% if reg.get_bit_fields() | length > 0 %}
         if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_data = data;
            m_be = byte_en;
            m_is_read = is_read;
            cov_bits.sample();
         end
       {% endif %}
       {% if reg.get_bit_fields_with_values() | sort(attribute='lsb') | length > 0 %}
         if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            sample_values();
            cov_fields.sample();
         end
       {% endif %}

      endfunction: sample
     {% endif %}

      virtual function void build();
     {% for field in reg.get_bit_fields() %}
         {{fix_name(field)}} = new("{{fix_name(field)}}");
     {% endfor %}
     {%- for field in reg.get_bit_fields() -%}
        {%- if field.flags.volatile %}
          {% set volatile = "1" %}
        {% elif TYPE_TO_INPUT[field.type] %}
          {% set volatile = "!" + prj.short_name + "_reg_pkg::s_relaxed_volatile" %}
        {% else %}
          {% set volatile = "0" %}
        {% endif %}
	{%  set mask = (2 ** field.width) - 1 %}
	{%- if field.reset_type == 1 %}
	{%-   set has_reset = 0 %}
	{%-   set reset = "'0" %}
	{%- elif field.reset_type == 2 %}
	{%-  set has_reset = 0 %}
        {%   set reset = "%d'h%x" % (field.width, field.reset_value.__and__(mask)) %}
	{%- else %}
        {%   set has_reset = 1 %}
        {%   set reset = "%d'h%x" % (field.width, field.reset_value.__and__(mask)) %}
	{%- endif %}
        {%- set ind_access = individual_access(field, reg) %}
        {%- set access = ACCESS_MAP[field.field_type] %}
	
         {{fix_name(field)}}.configure(
	    .parent(this),
	    .size({{field.width}}),
	    .lsb_pos({{field.lsb}}),
	    .access("{{access}}"),
	    .volatile({{volatile}}),
	    .reset({{reset}}),
	    .has_reset({{has_reset}}),
	    .is_rand({% if field.flags.can_randomize %}1{% else %}0{% endif %}),
	    .individually_accessible({{ind_access}})
	 );
     {%- endfor %}

      {% if reg.share != 0 %}
         uvm_resource_db #(bit)::set(
	    .scope({"REG::", get_full_name()}),
	    .name("NO_REG_TESTS"),
	    .val(1),
	    .accessor(this)
	 );
      {% else %}
         {% if reg.flags.do_not_test %}
	 // Dont bit bash
         uvm_resource_db #(bit)::set(
	    .scope({"REG::", get_full_name()}),
	    .name("NO_REG_BIT_BASH_TEST"),
	    .val(1),
	    .accessor(this)
	 );
         uvm_resource_db #(bit)::set(
	    .scope({"REG::", get_full_name()}),
	    .name("NO_REG_ACCESS_TEST"),
	    .val(1),
	    .accessor(this)
	 );
	 {% endif %}
         {% if reg.flags.do_not_reset_test  %}
         uvm_resource_db #(bit)::set(
	    .scope({"REG::", get_full_name()}),
	    .name("NO_REG_HW_RESET_TEST"),
	    .val(1),
	    .accessor(this)
	 );
         {% elif reg.strict_volatile() %}
           {% if reg.loose_volatile() %}
         uvm_resource_db #(bit)::set(
	    .scope({"REG::", get_full_name()}),
	    .name("NO_REG_HW_RESET_TEST"),
	    .val(1),
	    .accessor(this)
	 );
           {% else %}
         if ({{prj.short_name}}_reg_pkg::s_relaxed_volatile == 1'b0) begin
            uvm_resource_db #(bit)::set(
	       .scope({"REG::", get_full_name()}),
	       .name("NO_REG_HW_RESET_TEST"),
	       .val(1),
	       .accessor(this)
	    );
         end
           {% endif %}
	 {% endif %}
      {% endif %}
      endfunction : build

   endclass : reg__{{blk_inst.name}}__{{regset_inst.name}}__{{fix_reg(reg)}}
    {% endif %}
   {% endfor %}
{% endfor %}


  /*--------------------------------------------------------------------------
   *
   * Regset instantiations
   *
   *--------------------------------------------------------------------------
   */
{% for db, regset_inst, grp, grp_map, tag in db_grp_maps %}

class {{grp.name}}__{{regset_inst.name}}__regset extends uvm_reg_block;
    `uvm_object_utils({{grp.name}}__{{regset_inst.name}}__regset)

   {% for reg in db.get_all_registers()|remove_no_uvm %}
     {% if reg.ram_size %}
    mem_{{regset_inst.name}}__{{fix_reg(reg)}} {{fix_reg(reg)}};
     {% else %}
       {% if reg.dimension.resolve() > 1 %}
    rand reg__{{grp.name}}__{{regset_inst.name}}__{{fix_reg(reg)}} {{fix_reg(reg)}}[{{reg.dimension.resolve()}}];
       {% else %}
    rand reg__{{grp.name}}__{{regset_inst.name}}__{{fix_reg(reg)}} {{fix_reg(reg)}};
       {% endif %}
     {% endif %}
   {% endfor %}

   {% for map in grp_map %}
    uvm_reg_map {{map.name}}_map;
   {% endfor %}
   
   {% if db.coverage %}
    {{grp.name}}__{{regset_inst.name}}__reg_access_wrapper {{regset_inst.name}}_access_cg;
   {% endif %}

    function new(
       string name = "{{grp.name}}__{{regset_inst.name}}__regset"
    );
       super.new(name, build_coverage(UVM_CVR_ADDR_MAP));
       add_coverage(build_coverage(UVM_CVR_ADDR_MAP));
    endfunction

    function string access_mode(
       string def,
       int force_mode
    );
       if (force_mode == 0) begin
          return def;
       end else if (force_mode == 1) begin
          return "RO";
       end else begin
          return "WO";
       end
    endfunction : access_mode	       

    virtual protected function uvm_reg_map build_address_map(
       string map_name, int unsigned width,
       int force_mode
    );
       uvm_reg_map rmap;

       if ({{db.ports.data_bus_width}} > width) begin
          rmap = create_map(
	     .name(map_name),
	     .base_addr('h0),
	     .n_bytes(width /8),
	     .endian(UVM_LITTLE_ENDIAN)
	  );
       end else begin
          rmap = create_map(
	     .name(map_name),
	     .base_addr('h0),
	     .n_bytes({{db.ports.data_bus_width // 8}}),
	     .endian(UVM_LITTLE_ENDIAN)
	  );
       end

       if (force_mode != 3) begin
    {% for reg in db.get_all_registers()|remove_no_uvm %}
       {% if reg.share == 1 or reg.is_completely_read_only() %}
       {%   set mode = "RO" %}
       {% elif reg.share == 2 or reg.is_completely_write_only() %}
       {%   set mode = "WO" %}
       {% else %}
       {%   set mode = "RW" %}
       {% endif %}
       
       {% if reg.ram_size %}
          rmap.add_mem({{fix_reg(reg)}}, 'h{{"%04x" % reg.address}}, access_mode("{{mode}}", force_mode));
      {% else %}
         {% if reg.dimension.resolve() > 1 %}
           {% for i in range(0, reg.dimension.resolve()) %}
          rmap.add_reg({{fix_reg(reg)}}[{{i}}], 'h{{"%04x" % (reg.address + (i * (reg.width // 8)),)}}, access_mode("{{mode}}", force_mode));
           {% endfor %}
         {% else %}
          rmap.add_reg({{fix_reg(reg)}}, 'h{{"%04x" % reg.address}}, access_mode("{{mode}}", force_mode));
         {% endif %}
      {% endif %}
    {%- endfor %}
       end
       return rmap;
    endfunction : build_address_map

    function string extract_path(
       string msg
    );
       int start, stop;

       for (int i = 0; i < msg.len(); i++) begin
          if (msg[i] == ".") begin
             start = i + 1;
             break;
          end
       end

       stop = msg.len() - 1;
       for (int i = start; i < msg.len(); i++) begin
          if (msg[i] == "[") begin
             stop = i;
             break;
          end
       end
       return msg.substr(start, stop); 
    endfunction : extract_path

    virtual function void build();

{% if db.coverage %}
      if (get_coverage(UVM_CVR_ADDR_MAP)) begin
        {{regset_inst.name}}_access_cg = new("{{regset_inst.name}}_access_cg");
      end
{% endif %}

{% for reg in db.get_all_registers()|remove_no_uvm %}
{%   if reg.share == 0 %}
{%     set mode = "_" %}
{%   elif reg.share == 1 %}
{%     set mode = "_r_" %}
{%   else %}
{%     set mode = "_w_" %}
{%   endif %}
{%   if reg.ram_size %}
      {{fix_reg(reg)}} = new("{{fix_reg(reg)}}");
      {{fix_reg(reg)}}.configure(this);
{%   else %}
{%     if reg.dimension.resolve() > 1 %}
      foreach ({{fix_reg(reg)}}[i]) begin
         {{fix_reg(reg)}}[i] = new("{{fix_reg(reg)}}");
         {{fix_reg(reg)}}[i].configure(this);
         {{fix_reg(reg)}}[i].build();
{%       for field in reg.get_bit_fields() %}
         {{fix_reg(reg)}}[i].add_hdl_path_slice($sformatf("r%02x{{mode}}{fix_name(field)}}", {{reg.address}} + (i * {{reg.width // 8}})), {{field.lsb}}, {{field.width}});
{%       endfor %}
      end
{%     else %}
      {{fix_reg(reg)}} = new("{{fix_reg(reg)}}");
      {{fix_reg(reg)}}.configure(this);
      {{fix_reg(reg)}}.build();
{%       for field in reg.get_bit_fields() %}
      {{fix_reg(reg)}}.add_hdl_path_slice("r{{'%02x' % reg.address}}{{mode}}{{fix_name(field)}}", {{field.lsb}}, {{field.width}});
{%       endfor %}
{%     endif %}
{%   endif %}
{% endfor %}

   {% if grp_map|length == 1 %}
     {% for map in grp_map %}

      {{map.name}}_map = build_address_map("{{map.name}}_map", {{8 * prj.get_address_width(map.uuid)}}, s_access_map["{{map.name}}"][extract_path(get_full_name())]);
     {% endfor %}
   {% else %}
     {% for map in grp_map %}
      {{map.name}}_map = build_address_map("{{map.name}}_map", {{8 * prj.get_address_width(map.uuid)}}, s_access_map["{{map.name}}"][extract_path(get_full_name())]);
     {% endfor %}

   {% endif %}

    endfunction : build

   {% if db.coverage %}
    function void sample(
       uvm_reg_addr_t offset,
       bit is_read,
       uvm_reg_map map
    );
       if (get_coverage(UVM_CVR_ADDR_MAP)) begin
          {{regset_inst.name}}_access_cg.sample(offset, is_read);
       end
    endfunction: sample
   {% endif %}

  endclass : {{grp.name}}__{{regset_inst.name}}__regset

{% endfor %}

  /*--------------------------------------------------------------------------
   *
   * Blocks
   *
   *--------------------------------------------------------------------------
   */
{% for grp in group_maps %}

   class {{grp.name}}__blk extends uvm_reg_block;

     `uvm_object_utils({{grp.name}}__blk)

  {% for regset_inst in prj.blocks[grp.blkid].regset_insts %}
  {%    set regset = prj.regsets[regset_inst.regset_id] %}
  {%    if regset_inst.repeat.resolve() > 1 %}
     {{grp.name}}__{{regset_inst.name}}__regset {{regset_inst.name}}[{{regset_inst.repeat.resolve()}}];
  {%    else %}
     {{grp.name}}__{{regset_inst.name}}__regset {{regset_inst.name}};
  {%    endif %}
  {% endfor %}

  {% for item in group_maps[grp] %}
     uvm_reg_map {{item.name}}_map;
  {% endfor %}

     function new(string name = "{{grp.name}}__blk");
        super.new(name, build_coverage(UVM_NO_COVERAGE));
     endfunction : new

     function void build();
  {% if group_maps[grp]|length > 1 %}
    {% for map in group_maps[grp] %}
        {{map.name}}_map = create_map("{{map.name}}_map", 0, {{prj.get_address_width(map.uuid)}}, UVM_LITTLE_ENDIAN);
    {% endfor %}
  {% else %}
    {% for map in group_maps[grp] %}
        {{map.name}}_map = create_map("{{map.name}}_map", 0, {{prj.get_address_width(map.uuid)}}, UVM_LITTLE_ENDIAN);
    {% endfor %}
  {% endif %}

  {% for regset_inst in prj.blocks[grp.blkid].regset_insts %}
   {% set regset = prj.regsets[regset_inst.regset_id] %}
   {% if regset_inst.repeat.resolve() > 1 or regset.array %}
        for (int i = 0; i < {{regset_inst.repeat.resolve()}}; i++) begin
           {{regset_inst.name}}[i] = new($sformatf("{{regset_inst.name}}[%0d]", i));
      {% if regset_inst.hdl: %}
      	 {% if '%' in regset_inst.hdl %}
           {{regset_inst.name}}[i].configure(this, $sformatf("{{regset_inst.hdl}}", i));
	 {% else %}
           {{regset_inst.name}}[i].configure(this, "{{regset_inst.hdl}}");
	 {% endif %}
      {% else %}
           {{regset_inst.name}}[i].configure(this);
      {% endif %}
      
           {{regset_inst.name}}[i].build();
      {% for item in group_maps[grp] %}
        {% if group_maps[grp]| length > 1 %}
           {{item.name}}_map.add_submap({{regset_inst.name}}[i].{{item.name}}_map, 'h{{"%x" % regset_inst.offset}} + (i * 'h{{"%x" % (2 ** regset.ports.address_bus_width,)}}));
        {% else %}
           {{item.name}}_map.add_submap({{regset_inst.name}}[i].{{item.name}}_map, 'h{{"%x" % regset_inst.offset}} + (i * 'h{{"%x" % (2 ** regset.ports.address_bus_width,)}}));
        {% endif %}
        {% if regset.no_uvm %}
           uvm_resource_db#(bit)::set(
	      .scope({"REG::",{{regset_inst.name}}[i].get_full_name(),".*"}),
	      .name("NO_REG_TESTS"),
	      .val(1),
	      .accessor(this)
	   );
        {% endif %}
      {% endfor %}
        end
    {% else %}
        {{regset_inst.name}} = new("{{regset_inst.name}}");
        {{regset_inst.name}}.configure(this, "{{regset_inst.hdl}}");
	
        {{regset_inst.name}}.build();
      {% for item in group_maps[grp] %}
        {% if group_maps[grp]| length > 1 %}
        {{item.name}}_map.add_submap({{regset_inst.name}}.{{item.name}}_map, 'h{{"%x" % regset_inst.offset}});
        {% else %}
        {{item.name}}_map.add_submap({{regset_inst.name}}.{{item.name}}_map, 'h{{"%x" % regset_inst.offset}});
        {% endif %}
        {% if regset.no_uvm %}
        uvm_resource_db#(bit)::set(
	   .scope({"REG::",{{regset_inst.name}}.get_full_name(),".*"}),
	   .name("NO_REG_TESTS"),
	   .val(1),
	   .accessor(this)
	);
        {% endif %}
      {% endfor %}
    {%  endif %}
  {% endfor %}
      endfunction: build
  endclass : {{grp.name}}__blk
{% endfor %}

  /* Top level register block */
  class {{prj.short_name}}_reg_block extends uvm_reg_block;

     `uvm_object_utils({{prj.short_name}}_reg_block)
{% for grp in group_maps %}
{%   if grp.repeat > 1 %}
     {{grp.name}}__blk {{grp.name}}[{{grp.repeat}}];
{%   else %}
     {{grp.name}}__blk {{grp.name}};
{%   endif %}
{%- endfor %}
{% for data in used_maps %}
     uvm_reg_map {{data.name}}_map;
{% endfor %}

     function new(string name = "{{prj.short_name}}_reg_block");
        super.new(name, build_coverage(UVM_NO_COVERAGE));
     endfunction : new

     function void build();

{% for map in used_maps %}
        {{map.name}}_map = create_map("{{map.name}}_map", 'h{{"%x" % map.base}}, {{prj.get_address_width(map.uuid)}}, UVM_LITTLE_ENDIAN);
{% endfor %}

{% for grp in group_maps %}
  {% if grp.repeat <= 1 %}
        {{grp.name}} = new("{{grp.name}}");
        {{grp.name}}.configure(this, "{{grp.hdl_path}}");
        {{grp.name}}.build();

    {%- for mset in group_maps[grp] %}
        {{mset.name}}_map.add_submap({{grp.name}}.{{mset.name}}_map, 'h{{"%x" % grp.address_base}});
    {% endfor %}

  {% else %}

        foreach ({{grp.name}}[i]) begin
           {{grp.name}}[i] = new($sformatf("{{grp.name}}[%0d]", i));
    {% if grp.hdl_path %}
      {% if '%' in grp.hdl_path %}
           {{grp.name}}[i].configure(this, $sformatf("{{grp.hdl_path}}", i));
      {% else %}
           {{grp.name}}[i].configure(this, "{{grp.hdl_path}}");
      {% endif %}
    {% else %}
           {{grp.name}}[i].configure(this);
    {% endif %}
           {{grp.name}}[i].build();

    {% for map in group_maps[grp] %}
      {% set addr_size = prj.blocks[grp.blkid].address_size %}
           {{map.name}}_map.add_submap({{grp.name}}[i].{{map.name}}_map, 'h{{"%x" % grp.address_base}} + (i * 'h{{"%x" % addr_size}}));
    {% endfor %}
        end

  {% endif %}
{% endfor %}
        reset();
        lock_model();
     endfunction: build

  endclass : {{prj.short_name}}_reg_block
endpackage : {{prj.short_name}}_reg_pkg
