#! /usr/bin/env python3
#
# Copyright (C) 2017  Donald N. Allingham
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""
Import IPXACT data into regenerate
"""

import os
import sys
import xml.etree.ElementTree as ET
from collections import defaultdict, Counter
import re
import argparse
import math
import sre_constants
from pathlib import Path

if os.path.dirname(sys.argv[0]) != ".":
    if sys.argv[0][0] == "/":
        FULLPATH = os.path.dirname(sys.argv[0])
    else:
        FULLPATH = os.path.join(os.getcwd(), os.path.dirname(sys.argv[0]))
else:
    FULLPATH = os.getcwd()
sys.path.insert(0, os.path.dirname(FULLPATH))

from regenerate.db import Register, BitField, RegisterSet, ResetType, BitType


ARRAY_ELEMENT = re.compile(r"^(.*[^d])(\d+)(_reg)?\s*$", re.I)

TEXT2FIELD = {
    "read-only": BitType.READ_ONLY,
    "read-write": BitType.READ_WRITE,
    "write-only": BitType.WRITE_ONLY,
    "writeOnce": BitType.WRITE_ONLY,
}

TEXT2WRITE = {
    "oneToClear": BitType.WRITE_1_TO_CLEAR_SET,
    "oneToSet": BitType.WRITE_1_TO_SET,
}

RESERVED = [
    re.compile("^RESERVED"),
    re.compile("^RSVD"),
    re.compile("^UNSD"),
]


def convert_hex(value: str) -> int:
    try:
        return int(value, 0)
    except ValueError:
        return int(re.sub("(\d*)?'h", "0x", value), 0)
    

class RegGroup:
    def __init__(self):
        self.addr = 0
        self.regs = []
        self.repeat = 0

    def add_reg(self, reg):
        self.regs.append(reg)

    def set_reg_list(self, reg_list):
        self.regs = reg_list

    def append_reg_list(self, reg_list):
        self.regs = self.regs + reg_list

    def get_regs(self):
        return self.regs


class IpXactParser:
    """
    Parses the XML file, loading up the register database.
    """

    def __init__(self, keep_reserved=False):
        self._reg = None
        self.db_title = ""
        self._field = None
        self._fld_start = 0
        self._fld_width = 0
        self._token_list = []
        self._in_maps = False
        self._block_offset = 0
        self._block_list = [0]
        self._in_field_reset = False
        self._in_reg_reset = False
        self._reg_reset = (False, 0)
        self._last_reg = None
        self._last_index = -11
        self._ignore_count = 0
        self.reglist = []
        self._grp = False
        self.vendor = ""
        self._keep_reserved = keep_reserved
        self.scope = ""
        self.reg_names = set()
        
    def import_data(self, input_file):
        """
        Parses the specified input file.
        """
        tree = ET.parse(input_file)
        root = tree.getroot()

        self.filename = Path(input_file).with_suffix(".regp")

        self.scope = root.tag.split("}")[0] + "}"
        self.count = 0

        self.vendor = root.find(self.scope + "vendor").text
        self.db_title = root.find(self.scope + "name").text

        for mem_maps in root.findall(self.scope + "memoryMaps"):
            for mem_map in mem_maps.findall(self.scope + "memoryMap"):
                self.parse_mem_map(mem_map)

    def parse_mem_map(self, mem_map):
        name = mem_map.find(self.scope + "name")
        descr = mem_map.find(self.scope + "description")

        for addrblk in mem_map.findall(self.scope + "addressBlock"):
            self.parse_address_block(addrblk, 0)

    def parse_address_block(self, addrblk, original_base):
        base = addrblk.find(self.scope + "baseAddress")
        if base is not None:
            base_addr = convert_hex(base.text) + original_base
        else:
            base_addr = original_base

        for register in addrblk.findall(self.scope + "register"):
            self.start_register()
            name_tag = register.find(self.scope + "name")
            disp_tag = register.find(self.scope + "displayName")
            size_tag = register.find(self.scope + "size")
            descr_tag = register.find(self.scope + "description")
            addr_tag = register.find(self.scope + "addressOffset")

            token = name_tag.text.upper()
            count = 0

            new_token = token
            while new_token in self.reg_names:
                count += 1
                new_token = f"{token}_DUPLICATE_{count}"

            self.reg_names.add(new_token)
            
            if disp_tag is not None:
                self._reg.name = disp_tag.text
            else:
                self._reg.name = new_token.replace("_", " ")

            if descr_tag is not None:
                self._reg.description = descr_tag.text

            if addr_tag is not None:
                self._reg.address = convert_hex(addr_tag.text) + base_addr

            self._reg.token = new_token.upper()

            self._reg.width = convert_hex(size_tag.text)

            for field in register.findall(self.scope + "field"):
                self.start_field()

                element = field.find(self.scope + "name")
                if element is not None:
                    self._field.name = element.text.upper()
                else:
                    self._field.name = "UNNAMED"

                element = field.find(self.scope + "description")
                if element:
                    self._field.description = element.text

                element = field.find(self.scope + "resets")
                if element:
                    for value in element.find(self.scope + "reset"):
                        rval = convert_hex(value.text)
                        self._field.set_reset_value_int(rval)
                    
                self._field.lsb = convert_hex(
                    field.find(self.scope + "bitOffset").text
                )
                self._field.msb = (
                    self._field.lsb
                    + convert_hex(field.find(self.scope + "bitWidth").text)
                    - 1
                )
                if self._field.field_type not in (
                    BitType.WRITE_1_TO_SET,
                    BitType.WRITE_1_TO_CLEAR_SET,
                ):
                    self._field.field_type = TEXT2FIELD.get(
                        field.find(self.scope + "access").text,
                        BitType.READ_ONLY,
                    )
                self.end_field()

            self.end_register()
            self.count += 1

        for blk in addrblk.findall(self.scope + "addressBlock"):
            self.parse_address_block(blk, base_addr)

        # # crossreference(self._db)
        # if self._ignore_count:
        #     LOGGER.info(
        #         "Ignored %0d registers that contained no useful fields"
        #         % self._ignore_count
        #     )

    def start_register(self):
        self._reg = Register()

    def end_register(self):
        name_match = ARRAY_ELEMENT.match(self._reg.token)

        if not self._reg.get_bit_fields():
            self._reg = None
            self._reg_reset = (False, 0)
            return

        if name_match:
            new_token = name_match.groups()[0]
            new_name = name_from_token(new_token)
            if new_token[-1] == "_":
                new_token = new_token[:-1]
            idx = int(name_match.groups()[1])
        else:
            new_name = self._reg.name
            new_token = self._reg.token
            idx = -1

        if (
            idx >= 1
            and self._last_index + 1 == idx
            and self._last_reg
            and self._reg.array_cmp(self._last_reg)
        ):
            self._last_reg.dimension += 1
            self._last_reg.token = new_token
            self._last_reg.name = new_name
        else:
            if self._reg.get_bit_fields():
                self.reglist.append(self._reg)
                self._last_reg = self._reg
            else:
                self._last_reg = None
                self._ignore_count += 1
                self.reglist.append(self._reg)
        self._last_index = idx

        self._reg = None
        self._reg_reset = (False, 0)

    def start_field(self):
        self._field = BitField()

    def end_field(self):
        if self._keep_reserved or not ignore_by_field_name(self._field):
            self._reg.add_bit_field(self._field)
            if self._reg_reset[0]:
                self._field.reset_value = (
                    self._reg_reset[1] >> self._field.lsb
                ) & ((1 << self._field.width) - 1)
                self._field.reset_type = ResetType.NUMERIC

        self._field = None


class Groupings:
    """
    Groups registers, looking for repeated groups at the specified
    boundaries.
    """

    def __init__(self, registers):

        self.registers = registers

    def group(self, boundary):

        # Sort registers into groups based off the boundary
        reglist = defaultdict(list)
        for reg in self.registers:
            addr = (reg.address / boundary) * boundary
            reglist[addr].append(reg)

        # Look for adjacent, idential groups
        counter = Counter()
        newlist = defaultdict(RegGroup)

        for (cnt, key) in enumerate(sorted(reglist.keys())):

            if cnt == 0:
                counter[key] += 1
                newlist[key].set_reg_list(reglist[key])
                newlist[key].addr = key
            else:
                for new_key in newlist.keys():
                    if identical(reglist[key], newlist[new_key].get_regs()):
                        counter[new_key] += 1
                        break
                else:
                    newlist[key].set_reg_list(reglist[key])
                    newlist[key].addr = key
                    counter[key] += 1

        # Condense lists
        reglist = []

        old_count = -1

        for key in sorted(counter.keys()):
            count = counter[key]

            # Found duplicate
            if old_count == -1 or count > 1:
                rgrp = RegGroup()
                rgrp.addr = key
                rgrp.set_reg_list(newlist[key].get_regs())
                rgrp.repeat = count
                reglist.append(rgrp)
            else:
                rgrp.append_reg_list(newlist[key].get_regs())
                rgrp.repeat = 1
            old_count = count

        return (counter, reglist)


def crossreference(regset):
    names = sorted(
        [reg.name for reg in regset.get_all_registers()],
        key=len,
        reverse=True,
    )

    re_list = [r"([^`])({0}) ((R|r)egister)".format(name) for name in names]

    print("Cross Referencing...")

    for reg in regset.get_all_registers():
        for regex in re_list:
            reg.description = re.sub(regex, r"\1`\2`_ \3", reg.description)
        for field in reg.get_bit_fields():
            for regex in re_list:
                field.description = re.sub(
                    regex, r"\1`\2`_ \3", field.description
                )


def name_from_token(name):
    words = name.split("_")
    if len(words) > 1:
        if words[-1] == "REG":
            words = words[:-1]
    return " ".join([w.capitalize() for w in words])


def identical(list1, list2):
    for (i, item) in enumerate(list1):
        if not item.group_cmp(list2[i]):
            return False
    return True


def ignore_by_field_name(field):

    if field.field_type != BitType.READ_ONLY or field.reset_value != 0:
        return False

    for pattern in RESERVED:

        match = pattern.match(field.name)
        if match:
            return True

    return False


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Convert IPXACT files to regenerate files"
    )
    parser.add_argument("input_file", help="IPXACT XML input file")
    parser.add_argument(
        "--xref",
        dest="xref",
        action="store_true",
        default=False,
        help="Generate crossreferences in the comments if possible",
    )
    parser.add_argument(
        "--update",
        dest="update",
        action="store_true",
        default=False,
        help="Update data from previous file if available",
    )
    parser.add_argument(
        "--boundary",
        dest="boundary",
        default=0xFFFFFF,
        type=int,
        choices=[16, 32, 64, 128, 256, 512, 1024, 2048, 4096],
        help="Address boundary used to look for repeating groups",
    )
    parser.add_argument(
        "--keep-reserved",
        dest="keep_reserved",
        default=False,
        action="store_true",
        help="Does not removed read only fields with names matched reserved keyword",
    )
    parser.add_argument(
        "--xlate",
        dest="xlate",
        nargs="*",
        help="Regular expressions (python) to use to alter names in repeated groups",
    )
    parser.add_argument(
        "--reserved-regex",
        dest="regex",
        nargs="*",
        help="Regular expressions (python) to use to identify reserved fields",
    )

    args = parser.parse_args()

    if args.regex:
        for r in args.regex:
            try:
                pattern = re.compile(r)
                RESERVED.append(pattern)
            except sre_constants.error as msg:
                sys.stderr.write(
                    'Could not compile "%s" as a regular expression' % r
                )
                sys.stderr.write(" - %s\n" % str(msg))
                sys.exit(1)

    ip = IpXactParser()

    ip.import_data(args.input_file)

    # Group elements
    grp = Groupings(ip.reglist)

    (counters, data) = grp.group(args.boundary)

    src = []
    dest = []
    if args.xlate:
        for val in args.xlate:
            vals = val.split("=")
            if len(vals) == 2:
                src.append(vals[0])
                dest.append(vals[1])
            else:
                sys.stderr.write("Ignoring %s\n" % val)

    # Save files

    if not data:
        sys.stderr.write("No registers were found\n")

    for index, rgrp in enumerate(sorted(data)):

        if index == 0:
            title = ip.db_title
            filename = Path(title).with_suffix(".regr")
        else:
            title = f"{ip.db_title}_{index}"
            filename = Path(title).stem + f"_{index}.regr"

        regset = RegisterSet()
        regset.filename = filename

        # copy data from old regset, or create our own

        regset.owner = ip.vendor
        regset.organization = ip.vendor
        regset.descriptive_title = title
        regset.module_name = title.lower()
        regset.name = title.lower()
        regset.doc_pages.update_page("Overview", "", [])
        regset.doc_pages.update_page(
            "Import",
            f"Imported from IPXACT data provided by {ip.vendor}.",
            [],
        )

        max_addr = 0
        for r in rgrp.get_regs():
            if args.xlate:
                for i, s in enumerate(src):
                    r.token = re.sub(s, dest[i], r.token, flags=re.I)
                    r.name = re.sub(s, dest[i], r.name, flags=re.I)

            max_addr = max(r.address, max_addr)

            regset.add_register(r)

        if rgrp.repeat == 1:
            regset.address_bus_width = int(math.ceil(math.log(max_addr, 2)))
        else:
            regset.address_bus_width = int(
                math.ceil(math.log(args.boundary, 2))
            )

        if args.xref:
            crossreference(regset)

        regset.save()

    if len(data) > 1:
        print("%-20s %-8s Repeat" % ("Register Set", "Address"))
        print("%-20s %-8s %s" % ("-" * 20, "-" * 8, "-" * 6))
        for index, rgrp in enumerate(sorted(data)):
            print("%-20s %08x %d" % (filename, rgrp.addr, rgrp.repeat))
